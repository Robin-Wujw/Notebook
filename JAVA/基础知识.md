## 方法的重载(overload)

* 在同一个类中,允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
  “两同一不同”：同一个类、相同方法名
  参数列表不同：参数个数不同、参数类型不同
* 举例:
        Arrays类中重载的sort()/binarySearch()
* 判断是否为重载:
          跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系
* 在通过对象调用方法时，如何确定某一个指定的方法：
        方法名---->参数列表

## 匿名对象

* 创建的对象没有显式赋给一个对象名
* 匿名对象只能调用一次

```java
public class InstanceTest {
    public static void main(String[] args) {
        Phone p = new Phone();
        System.out.println(p);

        p.sendEmail();
        p.playGame();
        // 匿名
        new Phone().sendEmail();
        new Phone().playGame();

        new Phone().price=1999;
        new Phone().showPrice();
        //********************************
        PhoneMall mall = new PhoneMall();
        mall.show(new Phone());

    }
}
class PhoneMall{
    public void show(Phone phone){
        phone.sendEmail();
        phone.playGame();
    }
}
class Phone{
    double price;

    public void sendEmail(){
        System.out.println("发送邮件");
    }
    public void playGame(){
        System.out.println("玩游戏");
    }
    public void showPrice(){
        System.out.println("手机价格为："+price);
    }
}
```

## 构造器

类的结构三：构造器（构造方法、constructor）的使用:

### 构造器的作用：

 * 创建对象
 * 初始化对象的属性

### 说明

 * 如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器
 * 定义构造器的格式：权限修饰符 类名(形参列表){}
 * 一个类中定义的多个构造器，彼此构成重载
 * 一旦显示定义了类的构造器之后，系统就不再提供默认的空参构造器
 * 一个类中至少会有一个构造器。

```java
public class PersonTest {
    public static void main(String[] args) {
        //创建类的对象 ： new + 构造器
        Person p = new Person("Ro",12);
        p.eat();
        Person p1 = new Person("Tom");
        System.out.println(p1.name);
    }

}

class Person{
    String name;
    int age;
    //构造器
    public Person(){
        System.out.println("Person().....");
    }
    public Person(String n){
        name = n;
        System.out.println("Person().....");
    }
    public Person(String n,int a){
        this(n);//构造器调用构造器
        age = a;
        System.out.println("Person().....");
    }
    public void eat(){
        System.out.println("人吃饭");
    }
    public void study(){
        System.out.println("人学习");
    }
}
```

## 属性赋值先后顺序

### 总结：属性赋值的先后顺序

①默认初始化

②显示初始化

③构造器中初始化

④通过"对象.方法"或“对象.属性“的方式赋值

① ->②-> ③-> ④ 的先后顺序

## Package关键字的使用

### package关键字的使用

* 为了更好的实现项目中类的管理，提供包的概念
* 使用package声明类或接口所属的包，声明在源文件的首行
* 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、"见名知意"
* 每"."一次 代表一层文件目录。
* 补充： 同一个包下 不可以命名同名的接口、类
* 不同的包下 可以命名同名的接口、类

## Import 关键字的使用

* 在源文件中 显示使用import结构导入指定包下的类、接口
* 声明在包的声明和类的声明之间
* 如果需要导入多个结构 并列写出即可
* 可以使用xxx.*的方式，表示可以导入xxx包下的所有结构
* 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
* 如果使用的类或接口是本包下定义的则也可以省略import结构
* 如果在源文件中 使用了不同包下的同名类，则必须至少有一个类需要以全类名的方式显示
* 如果使用"xxx.*"的方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显示导入
* import static: 导入指定类或接口中的静态接口

## This 关键字的使用

* this可以用来修饰、调用： 属性、方法、构造器
* this修饰属性和方法：
  * this理解为：当前对象 或 当前正在创建的对象
  * 在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是通常情况下我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性重名时，我们必须显示的使用“this.变量”的方式表面此变量是属性而非形参。
  * 2.2 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。但是通常情况下我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性重名时，我们必须显示的使用“this.变量”的方式表面此变量是属性而非形参。
* this 调用构造器
  *  我们在类的构造器中，可以显示的使用"this(形参列表)"方式，调用本类中指定的其他构造器
  * 构造器中不能通过"this(形参列表)" 调用自己
  *  如果一个类中有n个构造器 则最多有n-1构造器使用了"this(形参列表)"
  * 规定"this(形参列表)"必须声明在当前构造器的首行
  * 构造器内部、最多只能声明一个"this(形参列表)"、用来调用其他构造器