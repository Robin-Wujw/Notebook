## 方法的重载(overload)

* 在同一个类中,允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
  “两同一不同”：同一个类、相同方法名
  参数列表不同：参数个数不同、参数类型不同
* 举例:
        Arrays类中重载的sort()/binarySearch()
* 判断是否为重载:
          跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系
* 在通过对象调用方法时，如何确定某一个指定的方法：
        方法名---->参数列表

## 匿名对象

* 创建的对象没有显式赋给一个对象名
* 匿名对象只能调用一次

```java
public class InstanceTest {
    public static void main(String[] args) {
        Phone p = new Phone();
        System.out.println(p);

        p.sendEmail();
        p.playGame();
        // 匿名
        new Phone().sendEmail();
        new Phone().playGame();

        new Phone().price=1999;
        new Phone().showPrice();
        //********************************
        PhoneMall mall = new PhoneMall();
        mall.show(new Phone());

    }
}
class PhoneMall{
    public void show(Phone phone){
        phone.sendEmail();
        phone.playGame();
    }
}
class Phone{
    double price;

    public void sendEmail(){
        System.out.println("发送邮件");
    }
    public void playGame(){
        System.out.println("玩游戏");
    }
    public void showPrice(){
        System.out.println("手机价格为："+price);
    }
}
```

## 构造器

类的结构三：构造器（构造方法、constructor）的使用:

### 构造器的作用：

 * 创建对象
 * 初始化对象的属性

### 说明

 * 如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器
 * 定义构造器的格式：权限修饰符 类名(形参列表){}
 * 一个类中定义的多个构造器，彼此构成重载
 * 一旦显示定义了类的构造器之后，系统就不再提供默认的空参构造器
 * 一个类中至少会有一个构造器。

```java
public class PersonTest {
    public static void main(String[] args) {
        //创建类的对象 ： new + 构造器
        Person p = new Person("Ro",12);
        p.eat();
        Person p1 = new Person("Tom");
        System.out.println(p1.name);
    }

}

class Person{
    String name;
    int age;
    //构造器
    public Person(){
        System.out.println("Person().....");
    }
    public Person(String n){
        name = n;
        System.out.println("Person().....");
    }
    public Person(String n,int a){
        this(n);//构造器调用构造器
        age = a;
        System.out.println("Person().....");
    }
    public void eat(){
        System.out.println("人吃饭");
    }
    public void study(){
        System.out.println("人学习");
    }
}
```

## 属性赋值先后顺序

### 总结：属性赋值的先后顺序

①默认初始化

②显示初始化

③构造器中初始化

④通过"对象.方法"或“对象.属性“的方式赋值

① ->②-> ③-> ④ 的先后顺序

## Package关键字的使用

### package关键字的使用

* 为了更好的实现项目中类的管理，提供包的概念
* 使用package声明类或接口所属的包，声明在源文件的首行
* 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、"见名知意"
* 每"."一次 代表一层文件目录。
* 补充： 同一个包下 不可以命名同名的接口、类
* 不同的包下 可以命名同名的接口、类

## Import 关键字的使用

* 在源文件中 显示使用import结构导入指定包下的类、接口
* 声明在包的声明和类的声明之间
* 如果需要导入多个结构 并列写出即可
* 可以使用xxx.*的方式，表示可以导入xxx包下的所有结构
* 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
* 如果使用的类或接口是本包下定义的则也可以省略import结构
* 如果在源文件中 使用了不同包下的同名类，则必须至少有一个类需要以全类名的方式显示
* 如果使用"xxx.*"的方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显示导入
* import static: 导入指定类或接口中的静态接口

## This 关键字的使用

* this可以用来修饰、调用： 属性、方法、构造器
* this修饰属性和方法：
  * this理解为：当前对象 或 当前正在创建的对象
  * 在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是通常情况下我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性重名时，我们必须显示的使用“this.变量”的方式表面此变量是属性而非形参。
  * 2.2 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。但是通常情况下我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性重名时，我们必须显示的使用“this.变量”的方式表面此变量是属性而非形参。
* this 调用构造器
  *  我们在类的构造器中，可以显示的使用"this(形参列表)"方式，调用本类中指定的其他构造器
  * 构造器中不能通过"this(形参列表)" 调用自己
  *  如果一个类中有n个构造器 则最多有n-1构造器使用了"this(形参列表)"
  * 规定"this(形参列表)"必须声明在当前构造器的首行
  * 构造器内部、最多只能声明一个"this(形参列表)"、用来调用其他构造器

## 方法的重写 

### (override/overwrite)

* 重写：子类继承父类之后，可以对父类中同名同参数的方法进行覆盖操作

* 应用：重写以后，当创建子类对象以后，通过子类对象去调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

* 重写的规定：

  * 方法的声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{

    //方法体

  ​        }

  约定俗成：子类中的叫重写的方法，父类中叫被重写的方法

  *  子类重写的方法的方法名和形参列表和父类被重写的方法的方法名和形参列表相同
  * 子类重写的方法的权限修饰符不小于父类中被重写的方法的权限修饰符

  > 特殊情况： 子类不能重写父类中声明为private权限的方法

  * 返回值类型：

    > 父类被重写得方法的返回值是void,则子类重写的方法的返回值类型只能是void

    > 父类被重写的方法的返回值类型是A类型，则子类重写的返回值类型可以是A类或A类的子类

    > 父类被重写的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)

  * 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放在异常处理里讲)

* 子类和父类的同名同参数的方法 要么都声明为非static的(考虑重写)，要么都声明为static(不叫重写)

* 面试题： 区分方法的重写和重载

## 体会四种不同的权限修饰

```java
public class Order {
    private int orderPrivate;
    int orderDefault;
    protected int orderProtected;
    public int orderPublic;

    private void methodPrivate(){
        orderPrivate = 1;
        orderDefault = 2;
        orderProtected = 3;
        orderPublic = 4;
    }
    void methodDefault(){
        orderPrivate = 1;
        orderDefault = 2;
        orderProtected = 3;
        orderPublic = 4;
    }
    protected void methodProtected(){
        orderPrivate = 1;
        orderDefault = 2;
        orderProtected = 3;
        orderPublic = 4;
    }
    public void methodPublic(){
        orderPrivate = 1;
        orderDefault = 2;
        orderProtected = 3;
        orderPublic = 4;
    }
}
```

* 同一个包中的其他类，不可以调用Order类中私有的属性、方法

* 在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法

## super关键字的使用

* super理解为：父类的

* super可以用来调用：属性、方法、构造器

* super的使用

  * 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。

    但是通常情况下，我们习惯省略"super."

  * 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式表面调用父类中声明的属性。

  * 特殊情况：当子类重写了父类的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法

* super调用构造器

  * 我们可以在子类构造器中显式使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
  * “super(形参列表)”的使用，必须声明在子类构造器的首行！
  * 我们在类的构造器中，针对于"this(形参列表)"或“super(形参列表)”只能二选一，不能同时出现
  * 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
  * 在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类中的构造器

## 回顾==的使用：

* ==：运算符

  * 可以使用在基本数据类型变量和引用数据类型变量中
  * 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等(不一定类型要相同)
  * 如果比较的是引用数据类型变量，比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体
  * 补充： == 符号使用时，必须保证符号左右两边的变量类型一致

* equals方法的使用：

  * 是一个方法而非运算符

  * 只能适用于引用数据类型

  * Object类中equals()的定义：

    public boolean equals(Object obj) {

    return (this == obj);

    }

    说明：Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体

  * 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同

  * 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的实体内容是否相同，那么我们就需要对Object类中的equals()方法进行重写

    重写的原则：比较两个对象的实体内容是否相同。