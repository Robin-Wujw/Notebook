# 封装继承多态

## 封装性

### 面向对象特征一： 封装与隐藏

#### 问题的引入：

* 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。
* 这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他的制约条件。但是，在实际问题中，
* 我们往往需要给属性赋值，加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加（比如：setLegs()）
* 同时，我们需要避免用户在使用“对象.属性”的方式对属性进行赋值，则需要将属性声明为私有的(private)。 此时，针对于属性就体现了封装性

#### 封装性的体现

* 我们将类的属性私有化(private)，同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值
* 拓展：封装性的体现：① 如上 ② 不对外暴露的私有的方法 ③ 单例模式..

#### 封装性的体现，需要权限修饰符来配合

* java规定的四种权限(从小到大排列): private、缺省(default)、protected、public
* 4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
* 具体的，四种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
* 修饰类的话，只能使用：缺省、public
* 总结封装性： Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及内部结构在调用时的可见性的大小

## 继承性

### 继承性的好处：

* 减少了代码的冗余、提高了代码的复用性
* 便于功能的扩展
* 为之后多态性的使用提供了前提

### 继承性的格式： class A extends B{}

A:子类、派生类、subclass

B:父类、超类、基类、superclass

* 体现： 一旦子类A继承父类B后，子类A中就获取了父类B中声明的所有的属性、方法。

  特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。

  只是因为封装性的影响，使得子类不能直接调用父类的结构而已。

* 子类继承父类以后，还可以声明自己特有的属性和方法

  子类和父类的关系，不同于集合和子集的关系。

   extends: 延展 扩展

### Java中关于继承性的规定：

* Java类中的单继承性：一个子类只能有一个父类
* 一个父类可派生出多个子类
* 子父类是相对的概念。
* 子类直接继承的父类称为：直接父类。 间接继承的父类称为：间接父类
* 子类继承父类之后，就获取了直接父类以及所有间接父类中声明的属性和方法

###  补充

* 如果我们没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类
* 所有的java类(除java.lang.Object类之外)都直接或间接的继承于java.lang.Object类
* 意味着所有的java类都具有java.lang.Object类声明的功能。